import { GlModal } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import VulnerabilityFindingModal from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue';
import SolutionCard from 'ee/vue_shared/security_reports/components/solution_card_vuex.vue';
import VulnerabilityDetailsGraphql from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';

const TEST_VULNERABILITY = {
  title: 'foo',
  uuid: '1',
  description: `Bracket object notation with user input is present, this might allow an attacker to access all properties of the object and even it's prototype, leading to possible code execution.`,
  severity: 'CRITICAL',
  project: {
    name: 'gitlab.com',
    webUrl: 'http://gitlab.com',
  },
  solution: 'foo',
  hasMergeRequest: false,
  remediations: [{}],
};

describe('Vulnerability finding modal', () => {
  let wrapper;

  const createWrapper = ({ findingOverrides = {}, isLoading = false } = {}) =>
    shallowMountExtended(VulnerabilityFindingModal, {
      data() {
        return {
          isLoading,
          finding: { ...TEST_VULNERABILITY, ...findingOverrides },
        };
      },
      propsData: {
        uuid: TEST_VULNERABILITY.uuid,
      },
      stubs: {
        GlModal,
      },
    });

  const findModal = () => wrapper.findComponent(GlModal);
  const findVulnerabilityDetails = () => wrapper.findComponent(VulnerabilityDetailsGraphql);
  const findSolutionCard = () => wrapper.findComponent(SolutionCard);

  beforeEach(() => {
    wrapper = createWrapper();
  });

  afterEach(() => {
    wrapper.destroy();
  });

  describe('modal instance', () => {
    it('gets passed the correct props', () => {
      expect(findModal().props()).toMatchObject({
        modalId: expect.any(String),
      });
    });

    it('makes the component emit "hide" when the modal gets closed', () => {
      expect(wrapper.emitted('hide')).toBeUndefined();

      findModal().vm.$emit('hide');

      expect(wrapper.emitted('hide')).toHaveLength(1);
    });
  });

  describe.each([true, false])('when loading state is "%s"', (isLoading) => {
    beforeEach(() => {
      wrapper = createWrapper({ isLoading });
    });

    it(`${isLoading ? 'shows' : 'does not show'} skeleton loaders`, () => {
      expect(wrapper.findByTestId('title-loading-indicator').exists()).toBe(isLoading);
      expect(wrapper.findByTestId('content-loading-indicator').exists()).toBe(isLoading);
    });
  });

  describe('finding details', () => {
    it('displays details about the given vulnerability finding', () => {
      const { description, severity } = TEST_VULNERABILITY;

      expect(findVulnerabilityDetails().props()).toMatchObject({
        description,
        severity,
      });
    });
  });

  describe('solution card', () => {
    it('gets passed the correct props', () => {
      expect(findSolutionCard().props()).toMatchObject({
        solution: TEST_VULNERABILITY.solution,
        hasMr: TEST_VULNERABILITY.hasMergeRequest,
        remediation: TEST_VULNERABILITY.remediations[0],
      });
    });

    it.each`
      condition                                | expectedHasDownloadValue | vulnerabilityData
      ${'merge request and remediations diff'} | ${true}                  | ${{ hasMergeRequest: false, remediations: [{ diff: ['foo'] }] }}
      ${'merge request'}                       | ${false}                 | ${{ hasMergeRequest: true }}
      ${'no remediation'}                      | ${false}                 | ${{ remediations: [] }}
      ${'no remediation diff'}                 | ${false}                 | ${{ remediations: [{ diff: [] }] }}
    `(
      'gets passed the "hasDownload" prop as "$expectedHasDownloadValue" when the vulnerability has $condition',
      ({ vulnerabilityData, expectedHasDownloadValue }) => {
        wrapper = createWrapper({ findingOverrides: vulnerabilityData });

        expect(findSolutionCard().props('hasDownload')).toBe(expectedHasDownloadValue);
      },
    );
  });
});
